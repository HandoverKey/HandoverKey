import {
  getDatabaseClient,
  UserRepository,
  SuccessorRepository,
  CheckinTokenRepository,
  NotificationDeliveryRepository,
  InactivitySettingsRepository,
} from "@handoverkey/database";
import {
  NotificationService as INotificationService,
  NotificationResult,
  ReminderType,
  NotificationMethod,
  DeliveryStatus,
  CheckInValidation,
} from "@handoverkey/shared/src/types/dead-mans-switch";
import { createHash, randomBytes } from "crypto";
import { emailService } from "./email-service";

export class NotificationService implements INotificationService {
  private static getUserRepository(): UserRepository {
    const dbClient = getDatabaseClient();
    return new UserRepository(dbClient.getKysely());
  }

  private static getSuccessorRepository(): SuccessorRepository {
    const dbClient = getDatabaseClient();
    return new SuccessorRepository(dbClient.getKysely());
  }

  private static getCheckinTokenRepository(): CheckinTokenRepository {
    const dbClient = getDatabaseClient();
    return new CheckinTokenRepository(dbClient.getKysely());
  }

  private static getNotificationDeliveryRepository(): NotificationDeliveryRepository {
    const dbClient = getDatabaseClient();
    return new NotificationDeliveryRepository(dbClient.getKysely());
  }

  private static getInactivitySettingsRepository(): InactivitySettingsRepository {
    const dbClient = getDatabaseClient();
    return new InactivitySettingsRepository(dbClient.getKysely());
  }

  /**
   * Sends a reminder notification to a user
   */
  async sendReminder(
    userId: string,
    reminderType: ReminderType,
  ): Promise<NotificationResult> {
    try {
      // Get user's notification preferences
      await this.getUserNotificationSettings(userId);
      const user = await this.getUserById(userId);

      if (!user) {
        throw new Error("User not found");
      }

      // Generate check-in link for the reminder
      const checkInLink = await this.generateCheckInLink(
        userId,
        7 * 24 * 60 * 60 * 1000,
      ); // 7 days

      // Create notification content based on reminder type
      const content = this.createReminderContent(
        reminderType,
        user.email,
        checkInLink,
      );

      // Send via primary notification method (email for now)
      const result = await this.sendEmailNotification(
        user.email,
        content.subject,
        content.body,
      );

      // Record the notification delivery
      await this.recordNotificationDelivery({
        userId,
        notificationType: reminderType,
        method: NotificationMethod.EMAIL,
        recipient: user.email,
        status: result.status,
        errorMessage: result.errorMessage,
      });

      return {
        id: result.id,
        userId,
        method: NotificationMethod.EMAIL,
        status: result.status,
        timestamp: new Date(),
        retryCount: 0,
        errorMessage: result.errorMessage,
      };
    } catch (error) {
      // Only log errors in non-test environments
      if (process.env.NODE_ENV !== "test") {
        console.error(
          `Failed to send ${reminderType} reminder to user ${userId}:`,
          error,
        );
      }

      // Record failed delivery
      await this.recordNotificationDelivery({
        userId,
        notificationType: reminderType,
        method: NotificationMethod.EMAIL,
        recipient: "unknown",
        status: DeliveryStatus.FAILED,
        errorMessage: error instanceof Error ? error.message : "Unknown error",
      });

      return {
        id: `failed-${Date.now()}`,
        userId,
        method: NotificationMethod.EMAIL,
        status: DeliveryStatus.FAILED,
        timestamp: new Date(),
        retryCount: 0,
        errorMessage: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Sends handover alerts to successors
   */
  async sendHandoverAlert(
    userId: string,
    successors: {
      name: string | null;
      email: string;
      encrypted_share?: string | null;
    }[],
    handoverProcessId?: string,
  ): Promise<NotificationResult[]> {
    const results: NotificationResult[] = [];

    for (const successor of successors) {
      try {
        const content = this.createHandoverAlertContent(
          successor.name || "Successor",
          successor.email,
          successor.encrypted_share,
        );

        const result = await this.sendEmailNotification(
          successor.email,
          content.subject,
          content.body,
        );

        await this.recordNotificationDelivery({
          userId,
          notificationType: ReminderType.HANDOVER_INITIATED,
          method: NotificationMethod.EMAIL,
          recipient: successor.email,
          status: result.status,
          errorMessage: result.errorMessage,
          handoverProcessId,
        });

        results.push({
          id: result.id,
          userId,
          method: NotificationMethod.EMAIL,
          status: result.status,
          timestamp: new Date(),
          retryCount: 0,
          errorMessage: result.errorMessage,
        });
      } catch (error) {
        // Only log errors in non-test environments
        if (process.env.NODE_ENV !== "test") {
          console.error(
            `Failed to send handover alert to successor ${successor.email}:`,
            error,
          );
        }

        results.push({
          id: `failed-${Date.now()}-${successor.email}`,
          userId,
          method: NotificationMethod.EMAIL,
          status: DeliveryStatus.FAILED,
          timestamp: new Date(),
          retryCount: 0,
          errorMessage:
            error instanceof Error ? error.message : "Unknown error",
        });
      }
    }

    return results;
  }

  /**
   * Sends handover cancellation notifications to successors
   */
  async sendHandoverCancellation(
    userId: string,
    successors: string[],
    reason: string,
  ): Promise<NotificationResult[]> {
    const results: NotificationResult[] = [];

    for (const successorId of successors) {
      try {
        const successor = await this.getSuccessorById(successorId);
        if (!successor) {
          continue;
        }

        const content = this.createHandoverCancellationContent(
          successor.name,
          reason,
        );

        const result = await this.sendEmailNotification(
          successor.email,
          content.subject,
          content.body,
        );

        // Record the notification delivery
        await this.recordNotificationDelivery({
          userId,
          method: NotificationMethod.EMAIL,
          notificationType: ReminderType.HANDOVER_CANCELLED,
          status: result.status,
          recipient: successor.email,
          errorMessage: result.errorMessage,
        });

        results.push({
          id: result.id,
          userId,
          method: NotificationMethod.EMAIL,
          status: result.status,
          timestamp: new Date(),
          retryCount: 0,
          errorMessage: result.errorMessage,
        });
      } catch (error) {
        if (process.env.NODE_ENV !== "test") {
          console.error(
            `Failed to send handover cancellation to successor ${successorId}:`,
            error,
          );
        }

        results.push({
          id: `failed-${Date.now()}`,
          userId,
          method: NotificationMethod.EMAIL,
          status: DeliveryStatus.FAILED,
          timestamp: new Date(),
          retryCount: 0,
          errorMessage:
            error instanceof Error ? error.message : "Unknown error",
        });
      }
    }

    return results;
  }

  /**
   * Generates a secure check-in link
   */
  async generateCheckInLink(
    userId: string,
    expiresIn: number,
  ): Promise<string> {
    const token = randomBytes(32).toString("hex");
    const tokenHash = createHash("sha256").update(token).digest("hex");
    const expiresAt = new Date(Date.now() + expiresIn);

    // Store the token hash in database
    const tokenRepo = NotificationService.getCheckinTokenRepository();
    await tokenRepo.create({
      user_id: userId,
      token_hash: tokenHash,
      expires_at: expiresAt,
    });

    // Return the check-in URL (token is not hashed in URL)
    const baseUrl = process.env.FRONTEND_URL || "http://localhost:5173";
    return `${baseUrl}/checkin?token=${token}`;
  }

  /**
   * Validates a check-in link token
   */
  async validateCheckInLink(token: string): Promise<CheckInValidation> {
    try {
      const tokenHash = createHash("sha256").update(token).digest("hex");

      const tokenRepo = NotificationService.getCheckinTokenRepository();
      const tokenData = await tokenRepo.findByTokenHash(tokenHash);

      if (!tokenData) {
        return {
          isValid: false,
          error: "Invalid check-in token",
        };
      }

      // Check if token is expired
      if (new Date() > new Date(tokenData.expires_at)) {
        return {
          isValid: false,
          error: "Check-in token has expired",
        };
      }

      // Check if token has already been used
      if (tokenData.used_at) {
        return {
          isValid: false,
          error: "Check-in token has already been used",
        };
      }

      return {
        isValid: true,
        userId: tokenData.user_id,
        remainingTime: new Date(tokenData.expires_at).getTime() - Date.now(),
      };
    } catch (error) {
      // Only log errors in non-test environments
      if (process.env.NODE_ENV !== "test") {
        console.error("Error validating check-in token:", error);
      }
      return {
        isValid: false,
        error: "Failed to validate check-in token",
      };
    }
  }

  /**
   * Marks a check-in token as used
   */
  async markCheckInTokenUsed(
    token: string,
    ipAddress?: string,
    userAgent?: string,
  ): Promise<void> {
    const tokenHash = createHash("sha256").update(token).digest("hex");

    const tokenRepo = NotificationService.getCheckinTokenRepository();
    await tokenRepo.markAsUsed(tokenHash, ipAddress, userAgent);
  }

  /**
   * Private helper methods
   */

  private async sendEmailNotification(
    to: string,
    subject: string,
    body: string,
  ): Promise<{ id: string; status: DeliveryStatus; errorMessage?: string }> {
    try {
      // Use the actual email service
      await emailService.sendEmail(to, subject, body);

      const randomId = randomBytes(6).toString("hex");
      return {
        id: `email-${Date.now()}-${randomId}`,
        status: DeliveryStatus.SENT,
      };
    } catch (error) {
      console.error("Failed to send notification email:", error);
      return {
        id: `failed-${Date.now()}`,
        status: DeliveryStatus.FAILED,
        errorMessage: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  private createReminderContent(
    reminderType: ReminderType,
    userEmail: string,
    checkInLink: string,
  ): { subject: string; body: string } {
    const baseUrl = process.env.FRONTEND_URL || "http://localhost:5173";

    switch (reminderType) {
      case ReminderType.FIRST_REMINDER:
        return {
          subject: "HandoverKey Activity Reminder - 75% Threshold Reached",
          body: `
Hello,

This is a friendly reminder that your HandoverKey account has been inactive for a while. 
You've reached 75% of your configured inactivity threshold.

To reset your activity timer, you can either:
1. Log into your HandoverKey account: ${baseUrl}/login
2. Use this secure check-in link: ${checkInLink}

If you don't take any action, you'll receive additional reminders as you approach your handover threshold.

Best regards,
The HandoverKey Team
          `.trim(),
        };

      case ReminderType.SECOND_REMINDER:
        return {
          subject: "HandoverKey Activity Reminder - 85% Threshold Reached",
          body: `
Hello,

Your HandoverKey account has been inactive for an extended period. 
You've now reached 85% of your configured inactivity threshold.

IMPORTANT: Please take action soon to prevent automatic handover of your digital assets.

To reset your activity timer:
1. Log into your HandoverKey account: ${baseUrl}/login
2. Use this secure check-in link: ${checkInLink}

Best regards,
The HandoverKey Team
          `.trim(),
        };

      case ReminderType.FINAL_WARNING:
        return {
          subject: "URGENT: HandoverKey Final Warning - 95% Threshold Reached",
          body: `
URGENT NOTICE

Your HandoverKey account has reached 95% of your inactivity threshold. 
If you don't take action soon, the automatic handover process will begin.

IMMEDIATE ACTION REQUIRED:
1. Log into your HandoverKey account: ${baseUrl}/login
2. Use this secure check-in link: ${checkInLink}

If you're unable to access your account, please contact support immediately.

Best regards,
The HandoverKey Team
          `.trim(),
        };

      default:
        return {
          subject: "HandoverKey Activity Reminder",
          body: `
Hello,

This is a reminder about your HandoverKey account activity.

To reset your activity timer, please log in: ${baseUrl}/login
Or use this secure check-in link: ${checkInLink}

Best regards,
The HandoverKey Team
          `.trim(),
        };
    }
  }

  private createHandoverAlertContent(
    successorName: string,
    _successorEmail: string,
    encryptedShare?: string | null,
  ): { subject: string; body: string } {
    const baseUrl = process.env.FRONTEND_URL || "http://localhost:5173";
    const shareSection = encryptedShare
      ? `
YOUR KEY SHARE:
----------------------------------------
${encryptedShare}
----------------------------------------

KEEP THIS SAFE. You will need this key share, combined with others, to unlock the digital vault.
`
      : `
NOTE: No digital key share was found for this account. You may need to coordinate with the user's legal representatives or other successors.
`;

    return {
      subject: "HandoverKey: Digital Asset Handover Initiated",
      body: `
Dear ${successorName},

A HandoverKey user has designated you as a successor for their digital assets. 
The handover process has been initiated due to prolonged inactivity.

${shareSection}

Next steps:
1. Visit HandoverKey: ${baseUrl}
2. Follow the successor verification process
3. Access the encrypted digital assets once verified

If you believe this is an error or have questions, please contact HandoverKey support.

Best regards,
The HandoverKey Team
      `.trim(),
    };
  }

  private createHandoverCancellationContent(
    successorName: string,
    reason: string,
  ): { subject: string; body: string } {
    return {
      subject: "HandoverKey: Digital Asset Handover CANCELLED",
      body: `
Dear ${successorName},

The digital asset handover process that was previously initiated has been CANCELLED.

      Reason: ${reason}

No action is required from you.The digital keys previously shared(if any) are no longer valid for the current state of the vault(if re - encrypted) or simply should be disregarded as the user has regained control.

If you have questions, please contact the user directly or HandoverKey support.

Best regards,
      The HandoverKey Team
        `.trim(),
    };
  }

  private async getUserNotificationSettings(userId: string) {
    const settingsRepo = NotificationService.getInactivitySettingsRepository();
    const settings = await settingsRepo.findByUserId(userId);

    if (!settings) {
      return { notificationMethods: ["email"] };
    }

    return {
      notificationMethods: settings.notification_methods || ["email"],
    };
  }

  private async getUserById(userId: string) {
    const userRepo = NotificationService.getUserRepository();
    const user = await userRepo.findById(userId);

    if (!user) {
      return null;
    }

    return {
      id: user.id,
      email: user.email,
    };
  }

  private async getSuccessorById(successorId: string) {
    const successorRepo = NotificationService.getSuccessorRepository();
    const successor = await successorRepo.findById(successorId);

    if (!successor) {
      return null;
    }

    return {
      id: successor.id,
      name: successor.name || "Successor",
      email: successor.email,
      encryptedShare: successor.encrypted_share,
    };
  }

  private async recordNotificationDelivery(delivery: {
    userId: string;
    notificationType: ReminderType;
    method: NotificationMethod;
    recipient: string;
    status: DeliveryStatus;
    errorMessage?: string;
    handoverProcessId?: string;
  }): Promise<void> {
    const deliveryRepo =
      NotificationService.getNotificationDeliveryRepository();
    await deliveryRepo.create({
      user_id: delivery.userId,
      notification_type: delivery.notificationType,
      method: delivery.method,
      recipient: delivery.recipient,
      status: delivery.status,
      error_message: delivery.errorMessage ?? null,
      handover_process_id: delivery.handoverProcessId,
    });
  }
}
